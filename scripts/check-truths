#!/usr/bin/env sh

# Description: Verifies a set of assertions with the form "statement command=expected value", one per line.

check_statements_from_file() {
    error=0
    line_number=0

    printf "CHECKING %s ...\n" "$(basename "$1" | tr '[:lower:]' '[:upper:]' | color cyan)" | info

    while read -r line; do
        line_number=$((line_number + 1))
        
        if [ -n "$line" ]; then
            if echo "$line" | grep -qvE '^#'; then
                statement=$(echo "$line" | cut -d= -f1)
                expec_value=$(echo "$line" | cut -d= -f2- | tr -d "\n\r")
                evald_value="$(eval "$statement" 2>/dev/null | tr -d "\n\r")"

                color_symbol="green ."
                if [ "$expec_value" != "$evald_value" ]; then
                    [ -n "$DEBUG" ] && printf "Error on file [%s][%s]\nCommand [eval %s]\nResult [%s]\nExpected [%s]\n" "$1" "$line_number" "$statement" "$evald_value" "$expec_value"
                    error=1
                    color_symbol="red !"
                fi

                printf '%s' "$(color $color_symbol)" | info
            else
                printf '%s' "$(color yellow '#')" | info
            fi
        fi
    done <"$1"

    printf "\n%s\n" "$([ $error = 1 ] && color red "FAILED" || color green "PASSED")" | info
    return $error
}

info() {
    cat >&2
}

date_formatted() {
    date --rfc-3339=ns | cut -d. -f1
}

check_statements_from_dir() {
    GLOBAL_ERROR=0

    for file in "$1"/*; do
        if [ -f "$file" ]; then
            if ! check_statements_from_file "$file"; then
                GLOBAL_ERROR=1
            fi
        fi
    done

    return $GLOBAL_ERROR
}

[ -f "$1" ] && {
    date_formatted | info
    check_statements_from_file "$1"
    exit
}

[ -d "$1" ] && {
    date_formatted | info
    check_statements_from_dir "$1"
    exit
}

color red "A file or directory containing truth statements files must be given as a first argument" && exit 1
